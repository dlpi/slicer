<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - STL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        color: #fff;
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 100;
        display:block;
      }
      a { color: skyblue }
      .button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
      .highlight { background:orange; color:#fff; }
      span {
        display: inline-block;
        width: 60px;
        float: left;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <input id="slide" type="range" min="0" max="100" step="0.1" style="width:100%">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>

    <script src="../index.js"></script>

    <script src="STLLoader.js"></script>
    <script src="TrackballControls.js"></script>

    <script src="stats.min.js"></script>

    <script>
      /* global THREE, Stats, slice */
      var container, stats
      var camera, controls, scene, renderer
      init()
      animate()
      function init () {
        container = document.createElement('div')
        document.body.appendChild(container)

        camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000)
        camera.position.z = 300
        controls = new THREE.TrackballControls(camera, container)
        controls.rotateSpeed = 3.0
        controls.zoomSpeed = 1.2
        controls.panSpeed = 0.8
        controls.noZoom = false
        controls.noPan = false
        controls.staticMoving = false
        controls.dynamicDampingFactor = 0.3
        controls.keys = [65, 83, 68]
        controls.addEventListener('change', render)

        scene = new THREE.Scene()
        scene.fog = new THREE.Fog(0xffffff, 0.1, 0)

        var loader = new THREE.STLLoader()
        var facetsArray
        loader.load('extruder_1.75mm-filament_no-mount.stl', function (geometry) {
          facetsArray = geometry.faces.map(function (face) {
            return {verts: [
              [geometry.vertices[face.a].x, geometry.vertices[face.a].y, geometry.vertices[face.a].z],
              [geometry.vertices[face.b].x, geometry.vertices[face.b].y, geometry.vertices[face.b].z],
              [geometry.vertices[face.c].x, geometry.vertices[face.c].y, geometry.vertices[face.c].z]
            ]}
          })
          showSlice(0)
          var material = new THREE.MeshPhongMaterial({color: 0xFF0000, specular: 0x111111, shininess: 200, transparent: true, opacity: 0.75})
          var mesh = new THREE.Mesh(geometry, material)
          mesh.renderOrder = 1
          geometry.computeBoundingBox()
          var posX = -geometry.boundingBox.min.x - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x)
          var posY = -geometry.boundingBox.min.y - 0.5 * (geometry.boundingBox.max.y - geometry.boundingBox.min.y)
          var posZ = -geometry.boundingBox.min.z
          mesh.position.set(posX, posY, posZ)
          document.getElementById('slide').min = geometry.boundingBox.min.z
          document.getElementById('slide').max = geometry.boundingBox.max.z
          mesh.castShadow = false
          mesh.receiveShadow = false
          scene.add(mesh)
        })

        var img = new window.Image()
        function showSlice (z) {
          console.log('showSlice', z)
          if (facetsArray === undefined) return
          img.removeAttribute('width')
          img.removeAttribute('height')
          img.src = 'data:image/svg+xml;utf8,' + slice(facetsArray, z, z, 1)
          img.onload = function () {
            var texture = new THREE.Texture(this)
            texture.needsUpdate = true
            console.log(this.width, this.height)
            var qualityScale = 20
            this.width *= qualityScale
            this.height *= qualityScale
            sliceMesh.geometry.dispose()
            sliceMesh.geometry = new THREE.PlaneBufferGeometry(this.width / qualityScale, this.height / qualityScale)
            sliceMesh.material.map && sliceMesh.material.map.dispose()
            sliceMesh.material.map = texture
            sliceMesh.material.needsUpdate = true
            sliceMesh.position.set(0, 0, z)
          }
        }

        document.getElementById('slide').addEventListener('change', function (e) {
          showSlice(parseFloat(e.target.value))
        })

        var geometry = new THREE.PlaneBufferGeometry(1, 1)
        var material = new THREE.MeshBasicMaterial({
          color: 0x00FF00,
          specular: 0x0000FF,
          side: THREE.DoubleSide,
          alphaTest: 0.5
        })
        material.transparent = true
        var sliceMesh = new THREE.Mesh(geometry, material)
        sliceMesh.renderOrder = 0
        sliceMesh.rotation.set(Math.PI, 0, 0)
        sliceMesh.position.set(0, 0, 5)
        scene.add(sliceMesh)

        scene.add(new THREE.HemisphereLight(0xEEEEEE, 0x111111))

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setClearColor(scene.fog.color)
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.gammaInput = true
        renderer.gammaOutput = true
        renderer.shadowMap.enabled = false
        renderer.shadowMap.renderReverseSided = false
        container.appendChild(renderer.domElement)
        // stats
        stats = new Stats()
        container.appendChild(stats.dom)
        //
        window.addEventListener('resize', onWindowResize, false)
      }

      function onWindowResize () {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate () {
        window.requestAnimationFrame(animate)
        controls.update()
        render()
        stats.update()
      }

      function render () {
        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
