<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - STL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Monospace;
        background-color: #FFF;
        margin: 0px;
        overflow: hidden;
      }
      #content {
        position: relative;
        color: #444;
        top: 10px;
        left: 10%;
        width: 80%;
        text-align: center;
        z-index: 0;
        display:block;
      }
      #svg_view {
        display: inline-block;
        width:49%;
        height: 350px;
        background-color: #000;
      }
      #svg_view svg {
        width: 100%;
        height: 100%;
        transform: scaleY(-1);
      }
      #view {
        display: inline-block;
        width: 49%;
        height: 350px;
        z-index: 1;
      }
      a { color: skyblue }
      .button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
      .highlight { background:orange; color:#fff; }
      span {
        display: inline-block;
        width: 60px;
        float: left;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="content">
        <h1>Slicer</h1>
      <input id="slide" type="range" min="0" max="100" step="0.1" style="width:100%">
      <div id="svg_view"></div>
      <div id="view"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>

    <script src="../index.js?123"></script>

    <script src="STLLoader.js"></script>
    <script src="TrackballControls.js"></script>

    <script>
      /* global THREE, slice */
      var container
      var camera, controls, scene, renderer
      init()
      animate()
      function init () {
        container = document.getElementById('view')

        camera = new THREE.PerspectiveCamera(35, container.offsetWidth / container.offsetHeight, 1, 1000)
        camera.position.z = 0
        controls = new THREE.TrackballControls(camera, container)
        controls.rotateSpeed = 3.0
        controls.zoomSpeed = 1.2
        controls.panSpeed = 0.8
        controls.noZoom = false
        controls.noPan = false
        controls.staticMoving = false
        controls.dynamicDampingFactor = 0.3
        controls.keys = [65, 83, 68]
        controls.addEventListener('change', render)

        scene = new THREE.Scene()

        var loader = new THREE.STLLoader()
        var facetsArray
        loader.load('extruder_1.75mm-filament_no-mount.stl', function (geometry) {
          facetsArray = geometry.faces.map(function (face) {
            return {verts: [
              [geometry.vertices[face.a].x, geometry.vertices[face.a].y, geometry.vertices[face.a].z],
              [geometry.vertices[face.b].x, geometry.vertices[face.b].y, geometry.vertices[face.b].z],
              [geometry.vertices[face.c].x, geometry.vertices[face.c].y, geometry.vertices[face.c].z]
            ]}
          })
          showSlice(0)
          var material = new THREE.MeshPhongMaterial({color: 0xDDDDDD, specular: 0xFFFFFF, shininess: 0, transparent: true, opacity: 0.5})
          var mesh = new THREE.Mesh(geometry, material)
          mesh.renderOrder = 1
          geometry.computeBoundingBox()
          var posX = -geometry.boundingBox.min.x - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x)
          var posY = -geometry.boundingBox.min.y - 0.5 * (geometry.boundingBox.max.y - geometry.boundingBox.min.y)
          var posZ = -geometry.boundingBox.min.z
          mesh.position.set(posX, posY, posZ)
          // reset camera
          var w = (geometry.boundingBox.max.x - geometry.boundingBox.min.x)
          var h = geometry.boundingBox.max.y - geometry.boundingBox.min.y
          var objectSize = Math.max(w, h)
          var fov = camera.fov * (Math.PI / 180)
          camera.position.z = Math.abs(camera.aspect * objectSize / Math.sin(fov / 2))// Math.abs(objectSize / Math.sin(fov / 2))
          document.getElementById('slide').min = geometry.boundingBox.min.z
          document.getElementById('slide').max = geometry.boundingBox.max.z
          mesh.castShadow = false
          mesh.receiveShadow = false
          scene.add(mesh)
        })

        var img = new window.Image()
        var svgView = document.getElementById('svg_view')
        function showSlice (z) {
          console.log('showSlice', z)
          if (facetsArray === undefined) return
          img.removeAttribute('width')
          img.removeAttribute('height')
          var svg = slice(facetsArray, z, z, 1)
          img.src = 'data:image/svg+xml;utf8,' + svg
          svgView.innerHTML = svg
          img.onload = function () {
            var texture = new THREE.Texture(this)
            texture.needsUpdate = true
            console.log(this.width, this.height)
            var qualityScale = 20
            this.width *= qualityScale
            this.height *= qualityScale
            sliceMesh.geometry.dispose()
            sliceMesh.geometry = new THREE.PlaneBufferGeometry(this.width / qualityScale, this.height / qualityScale)
            sliceMesh.material.map && sliceMesh.material.map.dispose()
            sliceMesh.material.map = texture
            sliceMesh.material.needsUpdate = true
            sliceMesh.position.set(0, 0, z)
          }
        }

        document.getElementById('slide').addEventListener('change', function (e) {
          showSlice(parseFloat(e.target.value))
        })

        var geometry = new THREE.PlaneBufferGeometry(1, 1)
        var material = new THREE.MeshBasicMaterial({
          color: 0x00BCD4,
          specular: 0x0000FF,
          side: THREE.DoubleSide,
          alphaTest: 0.5,
          opacity: 0.75
        })
        material.transparent = true
        var sliceMesh = new THREE.Mesh(geometry, material)
        sliceMesh.renderOrder = 0
        sliceMesh.rotation.set(Math.PI, 0, 0)
        sliceMesh.position.set(0, 0, 5)
        scene.add(sliceMesh)

        scene.add(new THREE.HemisphereLight(0xEEEEEE, 0xCCCCCC))

        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true})
        renderer.setClearColor(0x000000, 0)
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(container.offsetWidth, container.offsetHeight)

        container.appendChild(renderer.domElement)

        window.addEventListener('resize', onWindowResize, false)
      }

      function onWindowResize () {
        camera.aspect = container.offsetWidth / container.offsetHeight
        camera.updateProjectionMatrix()
        renderer.setSize(container.offsetWidth, container.offsetHeight)
      }

      function animate () {
        window.requestAnimationFrame(animate)
        controls.update()
        render()
      }

      function render () {
        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
