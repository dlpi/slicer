<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - STL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      body {
        font-family: Monospace;
        background-color: #FFF;
        margin: 0px;
        overflow: hidden;
      }
      #content {
        position: relative;
        color: #444;
        top: 10px;
        left: 10%;
        width: 80%;
        text-align: center;
        z-index: 0;
        display:block;
      }
      #svg_view {
        display: inline-block;
        width:49%;
        height: 350px;
        background-color: #000;
      }
      #svg_view svg {
        width: 100%;
        height: 100%;
        transform: scaleY(-1);
      }
      #view {
        display: inline-block;
        width: 49%;
        height: 350px;
        z-index: 1;
      }
      a { color: skyblue }
      .button { background:#999; color:#eee; padding:0.2em 0.5em; cursor:pointer }
      .highlight { background:orange; color:#fff; }
      span {
        display: inline-block;
        width: 60px;
        float: left;
        text-align: center;
      }

      #infillPattern label input {
        display: none;
      }
      #infillPattern label input:checked + img{
        border-color: #0000dd;
      }
      #infillPattern label img {
        width: 20mm;
        height: 20mm;
        border: 1mm solid #ccc;
      }
    </style>
  </head>
  <body>
    <div id="content">
        <h1>Slicer</h1>
      <form>
      <input id="slide" type="range" min="0" max="100" step="0.1" style="width:100%">
      <input id="wallThickness" type="text" value="2">
      <div id="infillPattern"></div>
      </form>
      <div id="svg_view"></div>
      <div id="view"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>

    <script src="../index.js?123"></script>

    <script src="STLLoader.js"></script>
    <script src="TrackballControls.js"></script>

    <script>
      /* global THREE, slice */
      var container
      var camera, controls, scene, renderer, showSlice
      init()
      animate()
      function init () {
        container = document.getElementById('view')

        camera = new THREE.PerspectiveCamera(35, container.offsetWidth / container.offsetHeight, 1, 1000)
        camera.position.z = 0
        controls = new THREE.TrackballControls(camera, container)
        controls.rotateSpeed = 3.0
        controls.zoomSpeed = 1.2
        controls.panSpeed = 0.8
        controls.noZoom = false
        controls.noPan = false
        controls.staticMoving = false
        controls.dynamicDampingFactor = 0.3
        controls.keys = [65, 83, 68]
        controls.addEventListener('change', render)

        scene = new THREE.Scene()

        var loader = new THREE.STLLoader()
        var facetsArray
        loader.load('extruder_1.75mm-filament_no-mount.stl', function (geometry) {
          facetsArray = geometry.faces.map(function (face) {
            return {verts: [
              [geometry.vertices[face.a].x, geometry.vertices[face.a].y, geometry.vertices[face.a].z],
              [geometry.vertices[face.b].x, geometry.vertices[face.b].y, geometry.vertices[face.b].z],
              [geometry.vertices[face.c].x, geometry.vertices[face.c].y, geometry.vertices[face.c].z]
            ]}
          })
          var material = new THREE.MeshPhongMaterial({color: 0xDDDDDD, specular: 0xFFFFFF, shininess: 0, transparent: true, opacity: 0.5})
          var mesh = new THREE.Mesh(geometry, material)
          mesh.renderOrder = 1
          geometry.computeBoundingBox()
          var posX = -geometry.boundingBox.min.x - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x)
          var posY = -geometry.boundingBox.min.y - 0.5 * (geometry.boundingBox.max.y - geometry.boundingBox.min.y)
          mesh.position.set(posX, posY, 0)
          // reset camera
          var w = (geometry.boundingBox.max.x - geometry.boundingBox.min.x)
          var h = geometry.boundingBox.max.y - geometry.boundingBox.min.y
          var objectSize = Math.max(w, h)
          var fov = camera.fov * (Math.PI / 180)
          camera.position.z = Math.abs(camera.aspect * objectSize / Math.sin(fov / 2))// Math.abs(objectSize / Math.sin(fov / 2))
          let layer = geometry.boundingBox.min.z + 0.5 * (geometry.boundingBox.max.z - geometry.boundingBox.min.z)
          document.getElementById('slide').min = geometry.boundingBox.min.z
          document.getElementById('slide').max = geometry.boundingBox.max.z
          document.getElementById('slide').value = layer
          showSlice()
          mesh.castShadow = false
          mesh.receiveShadow = false
          scene.add(mesh)
        })

        var img = new window.Image()
        var svgView = document.getElementById('svg_view')
        showSlice = () => {
          var z = parseFloat(document.getElementById('slide').value)
          console.log('showSlice', z)
          if (facetsArray === undefined) return
          img.removeAttribute('width')
          img.removeAttribute('height')
          var options = {
            firstLayerPosition: z,
            lastLayerPosition: z,
            layerHeight: 0.1,
            infillPattern: document.querySelector('input[name="infillPattern"]:checked').value,
            wallThickness: document.getElementById('wallThickness').value
          }
          var svg = slice(facetsArray, options)
          img.src = 'data:image/svg+xml;utf8,' + svg
          svgView.innerHTML = svg
          img.onload = function () {
            var texture = new THREE.Texture(this)
            texture.needsUpdate = true
            console.log(this.width, this.height)
            var qualityScale = 20
            this.width *= qualityScale
            this.height *= qualityScale
            sliceMesh.geometry.dispose()
            sliceMesh.geometry = new THREE.PlaneBufferGeometry(this.width / qualityScale, this.height / qualityScale)
            sliceMesh.material.map && sliceMesh.material.map.dispose()
            sliceMesh.material.map = texture
            sliceMesh.material.needsUpdate = true
            sliceMesh.position.set(0, 0, z)
          }
        }

        document.getElementById('slide').addEventListener('input', showSlice)
        document.getElementById('wallThickness').addEventListener('change', showSlice)

        var geometry = new THREE.PlaneBufferGeometry(1, 1)
        var material = new THREE.MeshBasicMaterial({
          color: 0x00BCD4,
          specular: 0x0000FF,
          side: THREE.DoubleSide,
          alphaTest: 0.5,
          opacity: 0.75
        })
        material.transparent = true
        var sliceMesh = new THREE.Mesh(geometry, material)
        sliceMesh.renderOrder = 0
        sliceMesh.rotation.set(Math.PI, 0, 0)
        sliceMesh.position.set(0, 0, 5)
        scene.add(sliceMesh)

        scene.add(new THREE.HemisphereLight(0xEEEEEE, 0x111111))

        renderer = new THREE.WebGLRenderer({antialias: true, alpha: true})
        renderer.setClearColor(0x000000, 0)
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(container.offsetWidth, container.offsetHeight)

        container.appendChild(renderer.domElement)

        window.addEventListener('resize', onWindowResize, false)
      }

      function onWindowResize () {
        camera.aspect = container.offsetWidth / container.offsetHeight
        camera.updateProjectionMatrix()
        renderer.setSize(container.offsetWidth, container.offsetHeight)
      }

      function animate () {
        window.requestAnimationFrame(animate)
        controls.update()
        render()
      }

      function render () {
        renderer.render(scene, camera)
      }

      var infillPatternContainer = document.getElementById('infillPattern')
      var patterns = {
        'solid': '<pattern id="pattern" x="0" y="0" width="100%" height="100%" patternUnits="userSpaceOnUse"><rect width="100%" height="100%" fill="#fff" /></pattern>',
        'hollow':
          `<pattern id="pattern" x="0" y="0" width="2.5" height="2.5" patternUnits="userSpaceOnUse"></pattern>`,
        'square':
          `<pattern id="pattern" x="0" y="0" width="2.5" height="2.5" patternUnits="userSpaceOnUse">
            <rect width="100%" height="100%" fill="none" stroke="#fff" stroke-width="0.75" />
          </pattern>`,
        'hexagon':
          `<pattern id="pattern" x="0" y="0" width="5" height="2.88" patternUnits="userSpaceOnUse">
            <path fill='none' stroke='#fff' stroke-width="0.75" d='M0 0 l0.83 0 l0.83 1.44 l1.66 0 l0.83 -1.44 l0.83 0 M0 2.88 l0.83 0 l0.83 -1.44 m1.66 0 l0.83 1.44l0.83 0' />
          </pattern>`
      }
      Object.keys(patterns).forEach(function (id) {
        var label = document.createElement('label')
        label.addEventListener('click', showSlice)
        var input = document.createElement('input')
        input.type = 'radio'
        input.name = 'infillPattern'
        input.value = patterns[id]
        input.checked = true
        var img = document.createElement('img')
        label.appendChild(input)
        label.appendChild(img)
        img.src = `data:image/svg+xml;utf8,
        <svg version="1.1" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
        <defs>${patterns[id]}</defs>
        <rect x="0" y="0" width="100" height="100" fill="black" /><rect x="0" y="0" width="100" height="100" fill="url(#pattern)" />
        </svg>`
        infillPatternContainer.appendChild(label)
      })
    </script>
  </body>
</html>
